"use strict";
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythonLayerVersion = void 0;
const jsiiDeprecationWarnings = require("../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const path = require("path");
const lambda = require("aws-cdk-lib/aws-lambda");
const core_1 = require("aws-cdk-lib/core");
const bundling_1 = require("./bundling");
const metadata_resource_1 = require("aws-cdk-lib/core/lib/metadata-resource");
const prop_injectable_1 = require("aws-cdk-lib/core/lib/prop-injectable");
/**
 * A lambda layer version.
 *
 */
let PythonLayerVersion = (() => {
    let _classDecorators = [prop_injectable_1.propertyInjectable];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = lambda.LayerVersion;
    var PythonLayerVersion = class extends _classSuper {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            PythonLayerVersion = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static [JSII_RTTI_SYMBOL_1] = { fqn: "@aws-cdk/aws-lambda-python-alpha.PythonLayerVersion", version: "2.231.0-alpha.0" };
        /** Uniquely identifies this class. */
        static PROPERTY_INJECTION_ID = '@aws-cdk.aws-lambda-python-alpha.PythonLayerVersion';
        constructor(scope, id, props) {
            try {
                jsiiDeprecationWarnings._aws_cdk_aws_lambda_python_alpha_PythonLayerVersionProps(props);
            }
            catch (error) {
                if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                    Error.captureStackTrace(error, PythonLayerVersion);
                }
                throw error;
            }
            const compatibleRuntimes = props.compatibleRuntimes ?? [lambda.Runtime.PYTHON_3_7];
            const compatibleArchitectures = props.compatibleArchitectures ?? [lambda.Architecture.X86_64];
            // Ensure that all compatible runtimes are python
            for (const runtime of compatibleRuntimes) {
                if (runtime && runtime.family !== lambda.RuntimeFamily.PYTHON) {
                    throw new Error('Only `PYTHON` runtimes are supported.');
                }
            }
            // Entry and defaults
            const entry = path.resolve(props.entry);
            // Pick the first compatibleRuntime and compatibleArchitectures to use for bundling
            const runtime = compatibleRuntimes[0];
            const architecture = compatibleArchitectures[0];
            super(scope, id, {
                ...props,
                compatibleRuntimes,
                code: bundling_1.Bundling.bundle({
                    entry,
                    runtime,
                    architecture,
                    outputPathSuffix: 'python',
                    skip: !core_1.Stack.of(scope).bundlingRequired,
                    ...props.bundling,
                }),
            });
            // Enhanced CDK Analytics Telemetry
            (0, metadata_resource_1.addConstructMetadata)(this, props);
        }
        static {
            __runInitializers(_classThis, _classExtraInitializers);
        }
    };
    return PythonLayerVersion = _classThis;
})();
exports.PythonLayerVersion = PythonLayerVersion;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsYXllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsaURBQWlEO0FBQ2pELDJDQUF5QztBQUV6Qyx5Q0FBc0M7QUFFdEMsOEVBQThFO0FBQzlFLDBFQUEwRTtBQWdDMUU7OztHQUdHO0lBRVUsa0JBQWtCOzRCQUQ5QixvQ0FBa0I7Ozs7c0JBQ3FCLE1BQU0sQ0FBQyxZQUFZO2tDQUEzQixTQUFRLFdBQW1COzs7O1lBQTNELDZLQXFDQzs7Ozs7UUFwQ0Msc0NBQXNDO1FBQy9CLE1BQU0sQ0FBVSxxQkFBcUIsR0FBVyxxREFBcUQsQ0FBQztRQUU3RyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQThCOzs7Ozs7bURBSjdELGtCQUFrQjs7OztZQUszQixNQUFNLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbkYsTUFBTSx1QkFBdUIsR0FBRyxLQUFLLENBQUMsdUJBQXVCLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTlGLGlEQUFpRDtZQUNqRCxLQUFLLE1BQU0sT0FBTyxJQUFJLGtCQUFrQixFQUFFLENBQUM7Z0JBQ3pDLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztvQkFDOUQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO2dCQUMzRCxDQUFDO1lBQ0gsQ0FBQztZQUVELHFCQUFxQjtZQUNyQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN4QyxtRkFBbUY7WUFDbkYsTUFBTSxPQUFPLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsTUFBTSxZQUFZLEdBQUcsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFaEQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUU7Z0JBQ2YsR0FBRyxLQUFLO2dCQUNSLGtCQUFrQjtnQkFDbEIsSUFBSSxFQUFFLG1CQUFRLENBQUMsTUFBTSxDQUFDO29CQUNwQixLQUFLO29CQUNMLE9BQU87b0JBQ1AsWUFBWTtvQkFDWixnQkFBZ0IsRUFBRSxRQUFRO29CQUMxQixJQUFJLEVBQUUsQ0FBQyxZQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLGdCQUFnQjtvQkFDdkMsR0FBRyxLQUFLLENBQUMsUUFBUTtpQkFDbEIsQ0FBQzthQUNILENBQUMsQ0FBQztZQUVILG1DQUFtQztZQUNuQyxJQUFBLHdDQUFvQixFQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNuQzs7WUFwQ1UsdURBQWtCOzs7OztBQUFsQixnREFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgbGFtYmRhIGZyb20gJ2F3cy1jZGstbGliL2F3cy1sYW1iZGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdhd3MtY2RrLWxpYi9jb3JlJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgQnVuZGxpbmcgfSBmcm9tICcuL2J1bmRsaW5nJztcbmltcG9ydCB7IEJ1bmRsaW5nT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYWRkQ29uc3RydWN0TWV0YWRhdGEgfSBmcm9tICdhd3MtY2RrLWxpYi9jb3JlL2xpYi9tZXRhZGF0YS1yZXNvdXJjZSc7XG5pbXBvcnQgeyBwcm9wZXJ0eUluamVjdGFibGUgfSBmcm9tICdhd3MtY2RrLWxpYi9jb3JlL2xpYi9wcm9wLWluamVjdGFibGUnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIFB5dGhvbkxheWVyVmVyc2lvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFB5dGhvbkxheWVyVmVyc2lvblByb3BzIGV4dGVuZHMgbGFtYmRhLkxheWVyVmVyc2lvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBsYW1iZGEgbGF5ZXIuXG4gICAqL1xuICByZWFkb25seSBlbnRyeTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcnVudGltZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBweXRob24gbGF5ZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gT25seSBQeXRob24gMy43IGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGNvbXBhdGlibGVSdW50aW1lcz86IGxhbWJkYS5SdW50aW1lW107XG5cbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gYXJjaGl0ZWN0dXJlcyBjb21wYXRpYmxlIHdpdGggdGhpcyBsYXllci5cbiAgICogQGRlZmF1bHQgW0FyY2hpdGVjdHVyZS5YODZfNjRdXG4gICAqL1xuICByZWFkb25seSBjb21wYXRpYmxlQXJjaGl0ZWN0dXJlcz86IGxhbWJkYS5BcmNoaXRlY3R1cmVbXTtcbiAgLyoqXG4gICAqIEJ1bmRsaW5nIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGZ1bmN0aW9uLiBVc2UgdGhpcyB0byBzcGVjaWZ5IGN1c3RvbSBidW5kbGluZyBvcHRpb25zIGxpa2VcbiAgICogdGhlIGJ1bmRsaW5nIERvY2tlciBpbWFnZSwgYXNzZXQgaGFzaCB0eXBlLCBjdXN0b20gaGFzaCwgYXJjaGl0ZWN0dXJlLCBldGMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVXNlIHRoZSBkZWZhdWx0IGJ1bmRsaW5nIERvY2tlciBpbWFnZSwgd2l0aCB4ODZfNjQgYXJjaGl0ZWN0dXJlLlxuICAgKi9cbiAgcmVhZG9ubHkgYnVuZGxpbmc/OiBCdW5kbGluZ09wdGlvbnM7XG59XG5cbi8qKlxuICogQSBsYW1iZGEgbGF5ZXIgdmVyc2lvbi5cbiAqXG4gKi9cbkBwcm9wZXJ0eUluamVjdGFibGVcbmV4cG9ydCBjbGFzcyBQeXRob25MYXllclZlcnNpb24gZXh0ZW5kcyBsYW1iZGEuTGF5ZXJWZXJzaW9uIHtcbiAgLyoqIFVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyBjbGFzcy4gKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBQUk9QRVJUWV9JTkpFQ1RJT05fSUQ6IHN0cmluZyA9ICdAYXdzLWNkay5hd3MtbGFtYmRhLXB5dGhvbi1hbHBoYS5QeXRob25MYXllclZlcnNpb24nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBQeXRob25MYXllclZlcnNpb25Qcm9wcykge1xuICAgIGNvbnN0IGNvbXBhdGlibGVSdW50aW1lcyA9IHByb3BzLmNvbXBhdGlibGVSdW50aW1lcyA/PyBbbGFtYmRhLlJ1bnRpbWUuUFlUSE9OXzNfN107XG4gICAgY29uc3QgY29tcGF0aWJsZUFyY2hpdGVjdHVyZXMgPSBwcm9wcy5jb21wYXRpYmxlQXJjaGl0ZWN0dXJlcyA/PyBbbGFtYmRhLkFyY2hpdGVjdHVyZS5YODZfNjRdO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYWxsIGNvbXBhdGlibGUgcnVudGltZXMgYXJlIHB5dGhvblxuICAgIGZvciAoY29uc3QgcnVudGltZSBvZiBjb21wYXRpYmxlUnVudGltZXMpIHtcbiAgICAgIGlmIChydW50aW1lICYmIHJ1bnRpbWUuZmFtaWx5ICE9PSBsYW1iZGEuUnVudGltZUZhbWlseS5QWVRIT04pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGBQWVRIT05gIHJ1bnRpbWVzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW50cnkgYW5kIGRlZmF1bHRzXG4gICAgY29uc3QgZW50cnkgPSBwYXRoLnJlc29sdmUocHJvcHMuZW50cnkpO1xuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGNvbXBhdGlibGVSdW50aW1lIGFuZCBjb21wYXRpYmxlQXJjaGl0ZWN0dXJlcyB0byB1c2UgZm9yIGJ1bmRsaW5nXG4gICAgY29uc3QgcnVudGltZSA9IGNvbXBhdGlibGVSdW50aW1lc1swXTtcbiAgICBjb25zdCBhcmNoaXRlY3R1cmUgPSBjb21wYXRpYmxlQXJjaGl0ZWN0dXJlc1swXTtcblxuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBjb21wYXRpYmxlUnVudGltZXMsXG4gICAgICBjb2RlOiBCdW5kbGluZy5idW5kbGUoe1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgYXJjaGl0ZWN0dXJlLFxuICAgICAgICBvdXRwdXRQYXRoU3VmZml4OiAncHl0aG9uJyxcbiAgICAgICAgc2tpcDogIVN0YWNrLm9mKHNjb3BlKS5idW5kbGluZ1JlcXVpcmVkLFxuICAgICAgICAuLi5wcm9wcy5idW5kbGluZyxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgLy8gRW5oYW5jZWQgQ0RLIEFuYWx5dGljcyBUZWxlbWV0cnlcbiAgICBhZGRDb25zdHJ1Y3RNZXRhZGF0YSh0aGlzLCBwcm9wcyk7XG4gIH1cbn1cbiJdfQ==